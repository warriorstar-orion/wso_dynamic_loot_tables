-- dynamic_loot
--
-- This module disentangles some of the dynamic loot spawn implementation from
-- ZCP's `game_setup.script` and expands it to allow recursive loot tables.
--
-- Much of the data that used to be read from `dynamic_item_spawn.ltx` is now
-- either read from `dynamic_loot_dests.ltx` (for spawn locations in levels) or
-- `dynamic_loot_tables.tlx` (for loot table definitions). The original file
-- continues to be read for replacing items from vanilla spawn points, and
-- enumerating number of possible uses for spawned multi-use items.

local print_debug = game_setup.print_debug

-- pick from a weighted table
function weighted_random(pool)
	local poolsize = 0
	for _, v in pairs(pool) do
		poolsize = poolsize + v
	end
	local selection = math.random(1, poolsize)
	for k, v in pairs(pool) do
		selection = selection - v
		if selection <= 0 then
			return k
		end
	end
end

function load_tables(dyn_loot, ini_filename)
	ini_tables = ini_file(ini_filename)
	ini_tables:section_for_each(function(section)
		local count = ini_tables:line_count(section)
		dyn_loot.tables[section] = {}
		for i = 0, count - 1 do
			local _, id, value = ini_tables:r_line_ex(section, i, "", "")
			dyn_loot.tables[section][id] = value
		end
	end)
end

function load_destinations(dyn_loot, ini_filename)
	ini_dests = ini_file(ini_filename)
	ini_dests:section_for_each(function(section)
		local sec_total = 0
		local count = ini_dests:line_count(section)
		for i = 0, count - 1 do
			_, name, info = ini_dests:r_line_ex(section, i, "", "")
			if name and info then
				local t = str_explode(info, ",")
				if (#t == 6) and (t[1] ~= "NA") then
					dyn_loot.itm_info[name] = {
						typ = t[1],
						x = tonumber(t[2]),
						y = tonumber(t[3]),
						z = tonumber(t[4]),
						lvl_id = tonumber(t[5]),
						gm_id = tonumber(t[6]),
					}
					sec_total = sec_total + 1
				else
					print_debug("dynamic_loot.load_destinations line failed section={%s} info={%s}", section, info)
				end
			else
				print_debug("dynamic_loot.load_destinations failed to load info={%s}", info)
			end
		end
		print_debug("dynamic_loot.load_destinations section={%s} count={%s} loaded={%s}", section, count, sec_total)
	end)
end

function resolve_to_item(dyn_loot, name)
	if dyn_loot.tables[name] ~= nil then
		local weighted = weighted_random(dyn_loot.tables[name])
		return resolve_to_item(dyn_loot, weighted)
	end

	return name
end

function try_find_dest(dyn_loot, excluded_lvl)
	if excluded_lvl then
		local t = {}

		-- Gather validated item places to spawn at
		for name, _ in pairs(dyn_loot.itm_off) do
			if not string.find(name, excluded_lvl) then
				t[#t + 1] = name
			end
		end

		return (#t > 0) and t[math.random(#t)]
	end

	if not (dyn_loot.itm_off and size_table(dyn_loot.itm_off) > 0) then
		print_debug("! Game Setup | dyn_loot.itm_off is nil or empty")
		return
	end

	return random_key_table(dyn_loot.itm_off)
end

function try_spawn(dyn_loot, dest)
	-- Return if place already has spawned item
	for id, name in pairs(dyn_loot.itm_on) do
		if name == dest then
			print_debug("! Game Setup | place {%s} is already occupied", dest)
			return
		end
	end

	-- Get info
	local info = dyn_loot.itm_info[dest]
	if not info then
		print_debug("! Game Setup | no info is found for {%s}", dest)
		return
	end

	-- Get section
	local section = resolve_to_item(dyn_loot, info.typ)
	if not section then
		print_debug("! Game Setup | couldn't get section [%s] for type (%s)", section, info.typ)
		return
	end

	if not ini_sys:section_exist(section) then
		print_debug("! Game Setup | section [%s] doesn't exist", section)
		return
	end

	-- Info check
	if not (info.x and info.y and info.z and info.lvl_id and info.gm_id and true) then
		print_debug("! Game Setup | item {%s} has wrong or incomplete info", section)
		return
	end

	-- Spawn and adjust uses/condition/ammo size
	if IsItem("ammo", section) then
		local pos = vector():set(info.x, info.y, info.z)
		local se_obj = alife_create_item(section, { pos, info.lvl_id, info.gm_id })
		if se_obj then
			game_setup.add_marker(dest, section, se_obj.id, info.typ)

			dyn_loot.itm_on[se_obj.id] = dest
			dyn_loot.itm_off[dest] = nil

			local box_size = ini_sys:r_u32(section, "box_size")
			dyn_loot.itm_num[dest] = math.random(math.ceil(box_size * 0.15), math.ceil(box_size * 0.50))

			print_debug(
				"/ Game Setup | created ammo [%s](%s) - place: %s - size = %s",
				section,
				se_obj.id,
				dest,
				dyn_loot.itm_num[dest]
			)
		else
			print_debug("! Game Setup | ammo [%s] couldn't be created", section)
		end
	else
		local pos = vector():set(info.x, info.y, info.z)
		local se_obj = alife_create_item(section, { pos, info.lvl_id, info.gm_id })
		if se_obj then
			game_setup.add_marker(dest, section, se_obj.id, info.typ)

			dyn_loot.itm_on[se_obj.id] = dest
			dyn_loot.itm_off[dest] = nil

			-- Multi-use
			if dyn_loot.limited_uses[section] then
				dyn_loot.itm_num[dest] =
					math.random(dyn_loot.limited_uses[section][1], dyn_loot.limited_uses[section][2])

				print_debug(
					"/ Game Setup | created multiuse item [%s](%s) - place: %s - uses = %s",
					section,
					se_obj.id,
					dest,
					dyn_loot.itm_num[dest]
				)
			else
				local is_using_con = utils_item.is_degradable(nil, section)
				if is_using_con then
					-- Parts
					if IsItem("part", section) then
						dyn_loot.itm_num[dest] = (math.random(35, 75) / 100)
						print_debug(
							"/ Game Setup | created degraded item [%s](%s) - place: %s - con = %s",
							section,
							se_obj.id,
							dest,
							dyn_loot.itm_num[dest]
						)

					-- Degradable items
					else
						dyn_loot.itm_num[dest] = (math.random(30, 70) / 100)
						print_debug(
							"/ Game Setup | created degraded item [%s](%s) - place: %s - con = %s",
							section,
							se_obj.id,
							dest,
							dyn_loot.itm_num[dest]
						)
					end
				else
					print_debug("/ Game Setup | created item [%s](%s)", section, se_obj.id)
				end
			end
		else
			print_debug("! Game Setup | item [%s] couldn't be created", section)
		end
	end
end

function load_zcp_settings(dyn_loot, ini_filename)
	print_debug("dynamic_loot.load_zcp_settings ini_filename={%s}", ini_filename)
	local n, m = 0, 0
	local result, id, value = "", "", ""
	local name, info = "", ""

	local cfg_ini = ini_file(ini_filename)

	-- Gather uses
	n = cfg_ini:line_count("possible_uses") or 0
	for i = 0, n - 1 do
		result, id, value = cfg_ini:r_line_ex("possible_uses", i, "", "")
		if id and value then
			local t = str_explode(value, ",")
			dyn_loot.limited_uses[id] = { tonumber(t[1]) or 1, tonumber(t[2]) or 1 }
		end
	end

	-- Make list of non-spawned items
	for name, info in pairs(dyn_loot.itm_info) do
		dyn_loot.itm_off[name] = true
	end

	for id, name in pairs(dyn_loot.itm_on) do
		dyn_loot.itm_off[name] = nil
	end

	print_debug(
		"- Game Setup | itm_info: %s - itm_on: %s - itm_off: %s",
		size_table(dyn_loot.itm_info),
		size_table(dyn_loot.itm_on),
		size_table(dyn_loot.itm_off)
	)

	return cfg_ini -- return the ini because we need it later
end
